# -*- coding: utf-8 -*-
"""AutoML por producto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P7TXbkMJcRqSNtTSurKfKAg94VqA9c-3
"""

ColabNotebook = 'google.colab' in str(get_ipython())

if ColabNotebook:
    # monta G-drive en entorno COLAB
    from google.colab import drive
    drive.mount('/content/drive/')

    # carpeta donde se encuentran archivos .py auxiliares
    SALIDAS_DIR = '/content/drive/MyDrive/Colab Notebooks/SALIDAS/'
    DATOS_DIR = '/content/drive/MyDrive/Colab Notebooks/DATOS/'      # carpeta donde se encuentran los datasets
else:
    # configuración para notebook con instalación LOCAL
    SALIDAS_DIR = '../Salidas/'         # carpeta donde se encuentran archivos .py auxiliares
    DATOS_DIR   = '../Datos/' # carpeta donde se encuentran los datasets

import pandas as pd
import os
import numpy as np

# Leer archivo original
ruta_archivo = os.path.join(DATOS_DIR, 'sell-in.txt')
df = pd.read_csv(ruta_archivo, sep='\t')


# Asegurar orden
df = df.sort_values(by=['customer_id', 'product_id', 'periodo'])

df.drop(columns=['cust_request_qty', 'cust_request_tn', 'plan_precios_cuidados'], inplace=True)

ruta_archivo_a_predecir = os.path.join(DATOS_DIR, 'product_id_apredecir201912.txt')
df_a_predecir = pd.read_csv(ruta_archivo_a_predecir, sep='\t')

# Agrupar el df original para sumarizar tn por product_id y periodo
df = df.groupby(['periodo','product_id'], as_index=False)['tn'].sum()

#df_final = df_final.sort_values(by=['product_id', 'periodo'])
df_final = df.sort_values(by=['product_id', 'periodo'])

# Filtrar hasta dic 2019 y productos requeridos
# Leer lista de productos a predecir
with open(DATOS_DIR+"product_id_apredecir201912.txt", "r") as f:
    product_ids = [int(line.strip()) for line in f if line.strip().isdigit()]

df_final = df_final[
    (df_final['product_id'].isin(product_ids))
]

# 1. Todos los productos únicos
productos = df_final['product_id'].unique()

# 2. Todos los periodos únicos (los 36 que hay)
periodos = df_final['periodo'].unique()

# 3. Producto cartesiano
df_completo = pd.MultiIndex.from_product([productos, periodos], names=['product_id', 'periodo']).to_frame(index=False)

# 4. Merge con la base original
df_final = df_completo.merge(df_final, on=['product_id', 'periodo'], how='left')

# 5. Rellenar tn faltantes con 0
df_final['tn'] = df_final['tn'].fillna(0)

# Crear mapa periodo a lag
periodo_lag_map = {p: i + 1 for i, p in enumerate(sorted(df_final['periodo'].unique()))}
df_final['lag'] = df_final['periodo'].map(periodo_lag_map)

# Crear columnas t-1 a t-36: tn hacia atrás
for i in range(1, 37):
    df_final[f't-{i}'] = df_final.groupby('product_id')['tn'].shift(i)

# Año, mes, trimestre
df_final['anio'] = df_final['periodo'] // 100
df_final['mes'] = df_final['periodo'] % 100
df_final['trimestre'] = ((df_final['mes'] - 1) // 3) + 1

# Codificación cíclica del mes
df_final['mes_sin'] = np.sin(2 * np.pi * df_final['mes'] / 12)
df_final['mes_cos'] = np.cos(2 * np.pi * df_final['mes'] / 12)


# Diferencias (deltas)
for i in range(1, 36):
    df_final[f'delta_t-{i}'] = df_final.groupby([ 'product_id'])['tn'].diff(i)

for i in range(1, 36):
    df_final[f'delta_pct_t-{i}'] = df_final.groupby([ 'product_id'])['tn'].pct_change(i)


# Promedios móviles
ventana_moviles = [2, 3, 4, 5, 6, 9, 12, 15, 18, 21, 24]
for ventana in ventana_moviles:
    df_final[f'mov_avg_{ventana}'] = (
        df_final.groupby([ 'product_id'])['tn']
        .transform(lambda x: x.rolling(window=ventana, min_periods=1).mean())
    )

# Max móviles
ventana_moviles = [2, 3, 4, 5, 6, 9, 12, 15, 18, 21, 24]
for ventana in ventana_moviles:
    df_final[f'mov_max_{ventana}'] = (
        df_final.groupby([ 'product_id'])['tn']
        .transform(lambda x: x.rolling(window=ventana, min_periods=1).max())
    )

# Min móviles
ventana_moviles = [2, 3, 4, 5, 6, 9, 12, 15, 18, 21, 24]
for ventana in ventana_moviles:
    df_final[f'mov_min_{ventana}'] = (
        df_final.groupby([ 'product_id'])['tn']
        .transform(lambda x: x.rolling(window=ventana, min_periods=1).min())
    )

df_final['antiguedad'] = df_final.groupby([ 'product_id']).cumcount()

# Calcular la clase como ratio tn futuro / tn actual
df_final['tn_target_t+2'] = df_final.groupby('product_id')['tn'].shift(-2)

df_predict = df_final[df_final['lag'] == 36].copy()

df_final = df_final.dropna(subset=['tn_target_t+2'])

import h2o
from h2o.automl import H2OAutoML

h2o.init()

hf = h2o.H2OFrame(df_final)

target = 'tn_target_t+2'
features = [col for col in df_final.columns if col not in [ 'periodo', target]]

for col in features:
    hf[col] = hf[col].asnumeric()

aml = H2OAutoML(max_runtime_secs=60*60,
                sort_metric='RMSE',
                seed=123)

aml.train(x=features, y=target, training_frame=hf)

# Listado de los modelos ganadores
lb = aml.leaderboard
lb

# Se elige el modelo ganador
leader_model = aml.leader

from pprint import pprint

pprint(df_predict[features].columns)

# Suponiendo que df_predict es tu DataFrame con las features listas para predecir:
hf_predict = h2o.H2OFrame(df_predict[features])

for col in features:
    hf_predict[col] = hf_predict[col].asnumeric()

predictions = leader_model.predict(hf_predict)

preds_df = predictions.as_data_frame()

# preds_df tiene la columna 'predict'
# df_predict tiene 'product_id'

# Añadir la columna product_id a preds_df
preds_df['product_id'] = df_predict['product_id'].values
print(preds_df)

# Guardar archivo
preds_df.to_csv(SALIDAS_DIR+"predicciones_febrero2020_autogluon_automlh2o.csv", index=False)
