# -*- coding: utf-8 -*-
"""AUTOGLUON_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GYcbEMdsojnWQo7x4iBxNxmvYmYm4QMj

AutoGluon - Predicción de ventas (tn) por producto para febrero 2020
"""

ColabNotebook = 'google.colab' in str(get_ipython())

if ColabNotebook:
    # monta G-drive en entorno COLAB
    from google.colab import drive
    drive.mount('/content/drive/')

    # carpeta donde se encuentran archivos .py auxiliares
    SALIDAS_DIR = '/content/drive/MyDrive/Colab Notebooks/SALIDAS/'
    DATOS_DIR = '/content/drive/MyDrive/Colab Notebooks/DATOS/'      # carpeta donde se encuentran los datasets
else:
    # configuración para notebook con instalación LOCAL
    FUENTES_DIR = '../Salidas'         # carpeta donde se encuentran archivos .py auxiliares
    SALIDAS_DIR   = '../Datos/' # carpeta donde se encuentran los datasets

# -------- CONFIGURACIÓN DE EJECUCIÓN --------
RUN_PRED_SIN_FE = False
RUN_PRED_USD = False
RUN_PRED_FULL = False
RUN_PRED_BRAND = False
RUN_PRED_FE = True
# --------------------------------------------

# Importar librerías
import pandas as pd

from autogluon.timeseries import TimeSeriesPredictor, TimeSeriesDataFrame

# Cargar datasets
df_sellin = pd.read_csv(DATOS_DIR+"sell-in.txt", sep="\t")
df_productos = pd.read_csv(DATOS_DIR+"tb_productos.txt", sep="\t")

df_dolar_diario = pd.read_csv(DATOS_DIR+"CotizacionesBNA.csv", sep =";")

df_dolar_diario['Fecha cotizacion'] = pd.to_datetime(df_dolar_diario['Fecha cotizacion'], dayfirst=True)
df_dolar_diario['year'] = df_dolar_diario['Fecha cotizacion'].dt.year
df_dolar_diario['month'] = df_dolar_diario['Fecha cotizacion'].dt.month

df_dolar_diario['Venta'] = df_dolar_diario['Venta'].str.replace(',', '.', regex=False).astype(float)
df_dolar_mensual = df_dolar_diario.groupby(['year', 'month'])['Venta'].mean().reset_index()
df_dolar_mensual.rename(columns={'Venta': 'dolar_promedio_bna'}, inplace=True)

df_dolar_mensual['fecha'] = pd.to_datetime(
    df_dolar_mensual[['year', 'month']].assign(day=1)
)

df_dolar_mensual.drop(columns=['year', 'month'], inplace=True)

# Leer lista de productos a predecir
with open(DATOS_DIR+"product_id_apredecir201912.txt", "r") as f:
    product_ids = [int(line.strip()) for line in f if line.strip().isdigit()]

# Preprocesamiento
# Convertir periodo a datetime
df_sellin['timestamp'] = pd.to_datetime(df_sellin['periodo'], format='%Y%m')

# Filtrar hasta dic 2019 y productos requeridos
df_filtered = df_sellin[
    (df_sellin['timestamp'] <= '2019-12-01') &
    (df_sellin['product_id'].isin(product_ids))
]

# Agregar tn por periodo, cliente y producto
df_grouped = df_filtered.groupby(['timestamp', 'customer_id', 'product_id'], as_index=False)['tn'].sum()

# Agregar tn total por periodo y producto
df_monthly_product = df_grouped.groupby(['timestamp', 'product_id'], as_index=False)['tn'].sum()

# Agregar columna 'item_id' para AutoGluon
df_monthly_product['item_id'] = df_monthly_product['product_id']

# Crear TimeSeriesDataFrame
ts_data = TimeSeriesDataFrame.from_data_frame(
    df_monthly_product,
    id_column='item_id',
    timestamp_column='timestamp'
)

# Completar valores faltantes
ts_data = ts_data.fill_missing_values()

if RUN_PRED_SIN_FE:
    
    # Definir y entrenar predictor
    predictor = TimeSeriesPredictor(
        prediction_length=2,
        target='tn',
        eval_metric='WAPE',
        freq='MS'  # Frecuencia mensual (Month Start),
    )

    predictor.fit(ts_data, num_val_windows=3, time_limit=60*60)

    # Generar predicción
    forecast = predictor.predict(ts_data)

    # Extraer predicción media y filtrar febrero 2020
    forecast_mean = forecast['mean'].reset_index()
    print(forecast_mean.columns)

    # Tomar solo item_id y la predicción 'mean'
    resultado = forecast['mean'].reset_index()[['item_id', 'mean']]
    resultado.columns = ['product_id', 'tn']

    # Filtrar solo febrero 2020
    resultado = forecast['mean'].reset_index()
    resultado = resultado[resultado['timestamp'] == '2020-02-01']

    # Renombrar columnas
    resultado = resultado[['item_id', 'mean']]
    resultado.columns = ['product_id', 'tn']

    # Guardar archivo
    resultado.to_csv(SALIDAS_DIR+"predicciones_febrero2020_autogluon_timeseriespredictor_sin_FE.csv", index=False)
    print(resultado.head())

"""USD"""

df_monthly_product_USD = df_monthly_product.merge(
    df_dolar_mensual,
    left_on='timestamp',
    right_on='fecha',
    how='left'
)

# Crear TimeSeriesDataFrame
ts_data_usd = TimeSeriesDataFrame.from_data_frame(
    df_monthly_product_USD,
    id_column='item_id',
    timestamp_column='timestamp'
)

# Completar valores faltantes
ts_data_usd = ts_data_usd.fill_missing_values()

if RUN_PRED_USD:
    
    # Definir y entrenar predictor
    predictor_usd = TimeSeriesPredictor(
        prediction_length=2,
        target='tn',
        eval_metric='WAPE',
        freq='MS'  # Frecuencia mensual (Month Start),
    )

    predictor_usd.fit(ts_data_usd, num_val_windows=3, time_limit=60*60)

    # Generar predicción
    forecast_usd = predictor_usd.predict(ts_data_usd)

    # Extraer predicción media y filtrar febrero 2020
    forecast_mean_usd = forecast_usd['mean'].reset_index()
    print(forecast_mean_usd.columns)

    # Tomar solo item_id y la predicción 'mean'
    resultado_usd = forecast_usd['mean'].reset_index()[['item_id', 'mean']]
    resultado_usd.columns = ['product_id', 'tn']

    # Filtrar solo febrero 2020
    resultado_usd = forecast_usd['mean'].reset_index()
    resultado_usd = resultado_usd[resultado_usd['timestamp'] == '2020-02-01']

    # Renombrar columnas
    resultado_usd = resultado_usd[['item_id', 'mean']]
    resultado_usd.columns = ['product_id', 'tn']

    # Guardar archivo
    resultado_usd.to_csv(SALIDAS_DIR+"predicciones_febrero2020_autogluon_timeseriespredictor_usd.csv", index=False)
    print(resultado_usd.head())

"""Sin filtrar lista"""

# Agregar tn por periodo, cliente y producto
df_grouped_full = df_sellin.groupby(['timestamp', 'customer_id', 'product_id'], as_index=False)['tn'].sum()

# Agregar tn total por periodo y producto
df_monthly_product_full = df_grouped_full.groupby(['timestamp', 'product_id'], as_index=False)['tn'].sum()

# Agregar columna 'item_id' para AutoGluon
df_monthly_product_full['item_id'] = df_monthly_product_full['product_id']

# Crear TimeSeriesDataFrame
ts_data_full = TimeSeriesDataFrame.from_data_frame(
    df_monthly_product_full,
    id_column='item_id',
    timestamp_column='timestamp'
)

# Completar valores faltantes
ts_data_full = ts_data_full.fill_missing_values()

if RUN_PRED_FULL:
    
    # Definir y entrenar predictor
    predictor_full = TimeSeriesPredictor(
        prediction_length=2,
        target='tn',
        eval_metric='WAPE',
        freq='MS'  # Frecuencia mensual (Month Start),
    )

    predictor_full.fit(ts_data_full, num_val_windows=3, time_limit=60*60)

    # Generar predicción
    forecast_full = predictor_full.predict(ts_data_full)

    # Extraer predicción media y filtrar febrero 2020
    forecast_mean_full = forecast_full['mean'].reset_index()
    print(forecast_mean_full.columns)

    # Tomar solo item_id y la predicción 'mean'
    resultado_full = forecast_full['mean'].reset_index()[['item_id', 'mean']]
    resultado_full.columns = ['product_id', 'tn']

    # Filtrar solo febrero 2020
    resultado_full = forecast_full['mean'].reset_index()
    resultado_full = resultado_full[resultado_full['timestamp'] == '2020-02-01']

    # Renombrar columnas
    resultado_full = resultado_full[['item_id', 'mean']]
    resultado_full.columns = ['product_id', 'tn']

    # Filtrar productos requeridos
    resultado_full = resultado_full[
        (resultado_full['product_id'].isin(product_ids))
    ]

    # Guardar archivo
    resultado_full.to_csv(DATOS_DIR+"predicciones_febrero2020_autogluon_timeseriespredictor_full.csv", index=False)
    print(resultado_full.head())

"""Cat1 y Marca"""

df_monthly_product_brand = df_monthly_product.merge(
    df_productos[['product_id', 'cat1', 'brand']],
    on='product_id',
    how='left'
)

# Crear TimeSeriesDataFrame
ts_data_brand = TimeSeriesDataFrame.from_data_frame(
    df_monthly_product_brand,
    id_column='item_id',
    timestamp_column='timestamp'
)

# Completar valores faltantes
ts_data_brand = ts_data_brand.fill_missing_values()

if RUN_PRED_BRAND:
    
    # Definir y entrenar predictor
    predictor_brand = TimeSeriesPredictor(
        prediction_length=2,
        target='tn',
        eval_metric='WAPE',
        freq='MS'  # Frecuencia mensual (Month Start),
    )

    predictor_brand.fit(ts_data_brand, num_val_windows=3, time_limit=60*60)

    # Generar predicción
    forecast_brand = predictor_brand.predict(ts_data_brand)

    # Extraer predicción media y filtrar febrero 2020
    forecast_mean_brand = forecast_brand['mean'].reset_index()
    print(forecast_mean_brand.columns)

    # Tomar solo item_id y la predicción 'mean'
    resultado_brand = forecast_brand['mean'].reset_index()[['item_id', 'mean']]
    resultado_brand.columns = ['product_id', 'tn']

    # Filtrar solo febrero 2020
    resultado_brand = forecast_brand['mean'].reset_index()
    resultado_brand = resultado_brand[resultado_brand['timestamp'] == '2020-02-01']

    # Renombrar columnas
    resultado_brand = resultado_brand[['item_id', 'mean']]
    resultado_brand.columns = ['product_id', 'tn']

    # Guardar archivo
    resultado_brand.to_csv(SALIDAS_DIR+"predicciones_febrero2020_autogluon_timeseriespredictor_brand.csv", index=False)
    print(resultado_brand.head())

"""Categoría, marca y tipo de cambio BNA"""

df_monthly_product_FE = df_monthly_product.merge(
    df_dolar_mensual,
    left_on='timestamp',
    right_on='fecha',
    how='left'
)

df_monthly_product_FE = df_monthly_product_FE.merge(
    df_productos[['product_id', 'cat1', 'brand']],
    on='product_id',
    how='left'
)

# Crear TimeSeriesDataFrame
ts_data_FE = TimeSeriesDataFrame.from_data_frame(
    df_monthly_product_FE,
    id_column='item_id',
    timestamp_column='timestamp'
)

# Completar valores faltantes
ts_data_FE = ts_data_FE.fill_missing_values()

if RUN_PRED_FE:
    
    # Definir y entrenar predictor
    predictor_FE = TimeSeriesPredictor(
        prediction_length=2,
        target='tn',
        eval_metric='WAPE',
        freq='MS'  # Frecuencia mensual (Month Start),
    )

    predictor_FE.fit(ts_data_FE, num_val_windows=3, time_limit=60*60)

    # Generar predicción
    forecast_FE = predictor_FE.predict(ts_data_FE)

    # Extraer predicción media y filtrar febrero 2020
    forecast_mean_FE = forecast_FE['mean'].reset_index()
    print(forecast_mean_FE.columns)

    # Tomar solo item_id y la predicción 'mean'
    resultado_FE = forecast_FE['mean'].reset_index()[['item_id', 'mean']]
    resultado_FE.columns = ['product_id', 'tn']

    # Filtrar solo febrero 2020
    resultado_FE = forecast_FE['mean'].reset_index()
    resultado_FE = resultado_FE[resultado_FE['timestamp'] == '2020-02-01']

    # Renombrar columnas
    resultado_FE = resultado_FE[['item_id', 'mean']]
    resultado_FE.columns = ['product_id', 'tn']

    # Guardar archivo
    resultado_FE.to_csv(SALIDAS_DIR+"predicciones_febrero2020_autogluon_timeseriespredictor_FE.csv", index=False)
    print(resultado_FE.head())